= Implementation =

Our implementation has two main features. It relies on a rigorous pattern matcher that tries to eliminate as much heuristics as possible. It is able to procedually produce code that represents the values defined in the quantified expression by the set-builder notation. This representation in turn relies on our implementation of a class that implements Iterator and therefore can efficiently calculate allowed values on the fly through operations on sets. We will go into further detail in the following subsections.

Our implementation is, however, not yet tightly integrated into the OpenJML infrastructure. Currently it is in an experimental stadium and mostly relies extensively on string comparison. Future work will be to integrate it into the visitor class used in OpenJML that walks the AST generated by the parser and modifies it accordingly to RAC.

== Implementation of a Rigorous Pattern Matcher ==

We implemented a rigorous pattern matcher that analyzes an expression recursive through a unification-like algorithm. The pattern matcher is part of a binary tree that, if asked, will return code that produces another binary tree that represents the actual values. This behavior is implemented in QRange.java. The implementation was inspired by the original QSet class implemented as part of JML2.

=== Rigorous Pattern Matching ===

JML expressions are, after parsing, represented by a tree structure implemented in JmlExpression. The JmlExpression processed by the pattern matcher is the expression that defines which values are defined for a given variable name. The idea is to find all sub-expressions that mention a variable name without applying any arithmetic operators to it, therefore actually give a definition for its value range. This assures that only expressions that are intended to define values for a variable name actually define its values. Other sub-expressions are ignored. Further, the boolean expression is broken down until it contains an atomic boolean expression between integers, i.e. an expression of the form i == j. To achieve this behavior, we implemented two levels of pattern matcher.

The first level breaks a JmlBinaryExpr object down into its subexpressions and stores the representation by matching the operator of this binary expression. After our definition, a higher-level binary expression has either the operator && or ||. The underlying implication here is that this expression is actually building a set. Therefore we translate the operators into their set operation counterparts. && is defined as set intersection, || is defined as a set union. All not matched operators will result in an exception thrown which informs the user that the expression can not be evaluated.

Let op be a binary boolean operator and E1, E2 boolean expressions of any form.

{{{
[E1, op, E2] ->
if var not in E1, E2 then Ignore(), else
match op with
| && ==> Intersection([E1], [E2])
| || ==> Union([E1], [E2])
| <integer comparison> ==> Interval(E1, op, E2)
| _ ==> Exception
}}}

The second level of the pattern matcher performs a unification-like algorithm. First, note that a single atomic boolean expression can only define a single margin value of an interval. Mathematically this means that one of the two boundarys of the interval will be either infinity or negative infinity. Programmatically however, this is not a real problem as the lowest and highest representable integers are discrete values.

Because of this fact, the low and high border of an interval are set initially to Integer.MIN_VALUE, Integer.MAX_VALUE respectively. Then, the pattern matcher determines if the expression defines the lower or the upper border of the interval. The algorithm then unifies the expression so that the variable always takes the left part of the expression. Afterwards it is trivial to infer if the expression defines a high or a low boundary.

Let op be a binary boolean operator on integers, E1, E2 either the variable that should be defined or a (reference to an) integer, high and low datafields that together represent an interval.

{{{
[E1, op, E2] ->
if E2 = var & var not in E1 then [E2, op, E1] else
match op with
| <= ==> high = E2
| >= ==> low = E2
| <  ==> [E1, <=, E2 - 1]
| >  ==> [E1, >, E2 + 1]
| == ==> low == E2, high = E2
| != ==> low == E2 + 1, high = E2 - 1
| _  ==> Exception
}}}

The rule for the operator != is a way to define an interval where only a single value is not defined. The implementation of IntervalSet, which will execute the values computed here, allows this definition and produces valid results, as we will describe in the next section.

The outlined algorithm builds a binary tree of objects of type QRange, where the operation for union and intersection as well as the actual interval are subtypes of it. Additionally, we implemented an ignore subtype that indicates that this sub-expression should be ignored. After the recursive construction of the binary tree, a method translate can be called on the object that returns a string holding code to create the specified interval using the IntervalSet type.

=== Binary Tree Representing Set Operations ===


=== Generating For-Loops for Multiple Race Variables ===

How does our implementation work? What is special about it? What is novel?