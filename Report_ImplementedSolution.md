# Implementation #

Our implementation has two main features. It relies on a rigorous pattern matcher that tries to eliminate as much heuristics as possible. It is able to procedurally produce code that represents the values defined in the quantified expression by the set-builder notation. This representation in turn relies on our implementation of a class that implements Iterator and therefore can efficiently calculate allowed values on the fly through operations on sets. We will go into further detail in the following subsections.

Our implementation is, however, not yet tightly integrated into the OpenJML infrastructure. Currently it is in an experimental stadium and mostly relies extensively on string comparison. Future work will be to integrate it into the visitor class used in OpenJML that walks the AST generated by the parser and modifies it accordingly to RAC.

## QRange - Implementation of a Rigorous Pattern Matcher ##

We implemented a rigorous pattern matcher that analyzes an expression recursive through a unification-like algorithm. The pattern matcher is part of a binary tree that, if asked, will return code that produces another binary tree that represents the actual values. This behavior is implemented in QRange.java. The implementation was inspired by the original QSet class implemented as part of JML2. [4c,7]

### Rigorous Pattern Matching ###

JML expressions are, after parsing, represented by a tree structure implemented in JmlExpression. The JmlExpression processed by the pattern matcher is the expression that defines which values are defined for a given variable name. The idea is to find all sub-expressions that mention a variable name without applying any arithmetic operators to it, therefore actually give a definition for its value range. This assures that only expressions that are intended to define values for a variable name actually define its values. Other sub-expressions are ignored. Further, the boolean expression is broken down until it contains an atomic boolean expression between integers, i.e. an expression of the form i == j. To achieve this behavior, we implemented two levels of pattern matcher.

The first level breaks a JmlBinaryExpr object down into its subexpressions and stores the representation by matching the operator of this binary expression. After our definition, a higher-level binary expression has either the operator && or |. The underlying implication here is that this expression is actually building a set. Therefore we translate the operators into their set operation counterparts. && is defined as set intersection, || is defined as a set union. All not matched operators will result in an exception thrown which informs the user that the expression can not be evaluated.|
|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

Let op be a binary boolean operator and E1, E2 boolean expressions of any form.

```
[E1, op, E2] ->
if var not in E1, E2 then Ignore(), else
match op with
| && ==> Intersection([E1], [E2])
| || ==> Union([E1], [E2])
| <integer comparison> ==> Interval(E1, op, E2)
| _ ==> Exception
```

Note that if the first line's condition is hit, a QRange of type Ignore is returned. If the expression that is being evaluated is the only given one, our convention for the definition for this variable through Ignore will be _[Integer.MIN\_VALUE, Integer.MAX\_VALUE]_, as we presume that the user actually wants to check _every_ possible integer.

The second level of the pattern matcher performs a unification-like algorithm. First, note that a single atomic boolean expression can only define a single margin value of an interval. Mathematically this means that one of the two boundaries of the interval will be either infinity or negative infinity. Programmatically however, this is not a real problem as the lowest and highest representable integers are discrete values.

Because of this fact, the low and high border of an interval are set initially to Integer.MIN\_VALUE, Integer.MAX\_VALUE respectively. Then, the pattern matcher determines if the expression defines the lower or the upper border of the interval. The algorithm then unifies the expression so that the variable always takes the left part of the expression. Afterwards it is trivial to infer if the expression defines a high or a low boundary.

Let op be a binary boolean operator on integers, E1, E2 either the variable that should be defined or a (reference to an) integer, high and low data fields that together represent an interval.

```
[E1, op, E2] ->
if ++ in E1, E2 || -- in E1, E2 then Exception else
if E2 = var & var not in E1 then [E2, op^(-1), E1] else
match op with
| <= ==> high = E2
| >= ==> low = E2
| <  ==> [E1, <=, E2 - 1]
| >  ==> [E1, >, E2 + 1]
| == ==> low == E2, high = E2
| != ==> low == E2 + 1, high = E2 - 1
| _  ==> Exception
```

Pre- and postfix in- or decrementors are not allowed, as they would alter the value of race variables while defining another one. The rule for the operator != is a way to define an interval where only a single value is not defined. The implementation of IntervalSet, which will execute the values computed here, allows this definition and produces valid results, as we will describe in the next subsection. However, there are cases where the pattern-matcher does not apply correctly. We will outline these in the next section.

### Code Generation ###

The outlined algorithm builds a binary tree of objects of type QRange, where the operation for union and intersection as well as the actual interval are subtypes of it. Additionally, we implemented an ignore subtype that indicates that this sub-expression should be ignored. After the recursive construction of the binary tree, a method translate can be called on the object that returns a string holding code to create the specified interval using the IntervalSet type.

Translate walks the tree recursively. It is implemented on each sub-type differently and therefore returns the type-specific operation. I.e. the union type of QRange returns code to build a union of IntervalSet, the singleton type returns code to build a singleton of IntervalSet and so on. If a ignore type is found, the set operation is omitted and the respective other sub-tree's code is returned exclusively.

## IntervalSet - Binary Tree Representing Set Operations ##

IntervalSet is also implemented as a binary tree. Structure-wise, it is very similar to QRange. This makes sense, since QRange is a meta-level implementation of IntervalSet. During compile time, the structure of a QRange instance is projected one-to-one on the structure of a IntervalSet instance.

Additionally, IntervalSet implements Iterator and Iterable of Integer. This makes it convenient and quick to run over all values in an IntervalSet using a shorthand for.

```
for(int i: IntervalSet.interval(0, 10){
	System.out.println(i);
}
```

This will print out all numbers from and including 0 to 10.

IntervalSet has subclasses that represent union, intersection and a singleton, for the reasons outlined. Again, only the singleton type actually holds values that represent interval borders. While in QRange, these subclasses mostly only differ in the way they generate source code, they have three methods each that differ in behaviour. One simply determines through boolean operations, if a given value is inside the set. The methods getNextLow and getNextHigh can however calculate a new low or high value given the tree structure is interpreted as set-operations.

The main difference is, that the union subclass can answer two different lows, highs respectively, depending on what the current value is, when iterating over an IntervalSet, while intersection will only always answer the higher low or the lower high. If neither heigh nor low is greater than the current value, the current value itself is returned instead. Following this, the condition to stop iteration is that current equals low and high at the same time.

Due to set-builder notations not necessarily being properly written, it is not given that a balanced tree will result from parsing and evaluating a JML forall statement. Still, walking an un-balanced tree is faster as implementing the naive approach, especially because expressions usually are rather brief and therefore would not result in very deep trees.

There are still certain issues outstanding with this implementation, which we will describe in the next section.

## ForAll - Generating For-Loops for Multiple Race Variables ##

To generate a quantified expression including multiple race variables, we implemented a class that recurses over each declared variable in the quantified expression. It looks for a valid definition inside the range expression contained in the quantified expression and generates a nested for-loop for each variable. After the last variable has been processed, an assertion, as it is stated in the quantified expression, is placed in the body of the inner most for-loop.

The class returns the generated code on a call to translate(). In ForAll, there are as well still issues that need to be resolved as pointed out in the next section.

## Specifications in JML ##

We provide lightweight JML specifications throughout our implementation in as many places in the code as possible .